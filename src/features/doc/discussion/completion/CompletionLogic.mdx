import FolderTree from "../../ui/FolderTree"
import { completionConcerns, concernedFolderAndFiles, viewConcerns, promptConcerns } from "./data"


# Gestion de la completion et la vue des messages

### R√©cuperer la r√©ponse de l'api au serveur
La phase de la completion se joue uniquement pendant que l'agent est entrain de r√©pondre seulement.
c'est-√†-dire cette phase en cours o√π l'agent r√©pond petit √† petit.
**Une fois que l'agent √† finit de r√©pondre, la completion est fini**. et on stocke apr√®s toute le bout de phrase de l'agent combin√©s dans le state.

La gestion de la completion d√©j√† √©normement du la r√©ponse de l'api appel api de notre question de la [section pr√©c√©dente](/discussion/prompting/).

Car, on fait, la r√©cup√©ration petit √† petit de la r√©ponse, et l'affichage des r√©ponses petit √† petit aussi, c'est √ßa en fait la completion.

---

La gestion de la completion c√¥t√© front est fait par le state `agentSlice`

> Pourquoi ? **car c'est l'agent qui est en charge de la r√©ponse, toute r√©ponse vient de lui**.


1 - On envoie la requ√™te, une fois que l'agent r√©ponse, on cr√©er un stream via l'action `createStreamAction`
<div className="tip">
Un stream, on va dire que c'est une sorte de session pendant laquelle passe tout la r√©ponse de l'agent pour telle question.

Si on pose 2 questions, √† un m√™me agent, l'agent va cr√©er 2 streams diff√©rents ou il va r√©pondre petit √† petit √† la question.

C'est un syst√®me imaginaire que j'ai mis en place cot√© front, pour g√©rer la completion. en fait. J'explique juste.
c'est une sorte de canal je pense, auquel sont l'agent envoie petit √† petit sa r√©ponse pour telle question √† telle discussion.
Et le stream arrange les phrases et les stocke temporairement.
</div>

2 - √Ä chaque fois que l'agent r√©pond, on met aussi √† jour notre pile de r√©ponse dans le stream, via l'action `updateStreamContentAction`


3 - Et une fois que l'agent √† fini de r√©pondre, on assemble les messages au complet, on ajoute la toute nouvelle message au complet dans le state des messages.
On supprime ce canal de stream car toute la r√©ponse a √©t√© r√©cuperer via l'action `cancelStreamAction` 

<div class="note">
Ceci va √™tre parler dans la section suivante, mais le state qui stocke chaque completion(chaque r√©ponse) se trouve dans `state.agent.completions`. 
Car oui, notre syst√®me de chat et notre state redux par cons√©quent :) prend en charge la gestion de plusieurs r√©ponses dans plusieurs discussions en instantan√©.

Chaque completion, r√©ponse non compl√®te et r√©cuperer petit √† petit, est stock√© dans le state `state.agent.completions`.

</div>


C√¥t√© code

```tsx
  // Dans UserPromptForm.tsx

  ...

  const dispatch = useAppDispatch();

  const { status, data } = await askAgentService(appAgent, payload());
      if (status === "error") {
        const error = data;
        const errorMessage = handleAskAgentError(error);
        const fullErrorMessage = builderChatErrorMessage(
          TranslationApp,
          errorMessage
        );
        // afficher une erreur et annuler la completion si il y a erreur lors de r√©cup√©ration du r√©ponse de l'agent
        dispatch(
          addMessageAction({
            content: fullErrorMessage,
            type: MessageType.Error,
            name: getAgentName(agent) === "" ? myAuxName : getAgentName(agent),
            id: uuidv4(),
            createdAt: new Date(),
            conversationId: conversationId,
            agentChanged: false,
            filesURL: images,
            myAuxId: activeMyaux ? activeMyaux.id : "",
            author:
              user && JSON.parse(user)
                ? JSON.parse(user)[0].f_Name + " " + JSON.parse(user)[0].l_Name
                : "",
          })
        );
      }
      const reader = data;
      let completion = "";
      let firstCompletion = false;
      const decoder = new TextDecoder("utf-8");

      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          // end stream
          dispatch(
            cancelStreamAction({
              conversationId: conversationId,
              agent: appAgent,
            })
          );
          const textMessage = completion.split("data:");
          const createdTime = extractTimestamp(
            textMessage[textMessage.length - 1]
          );
          dispatch(
            addMessageAction({
              content: queryReverter(
                urlCollectionTabs,
                formatMessageAI(completion).query
              ),
              type: MessageType.AI,
              name:
                getAgentName(appAgent) === ""
                  ? myAuxName
                  : getAgentName(appAgent),
              id: uuidv4(),
              createdAt:
                createdTime !== null ? new Date(createdTime) : new Date(),
              conversationId: conversationId,
              agentChanged:
                lastMessage?.name !==
                (getAgentName(appAgent) === ""
                  ? myAuxName
                  : getAgentName(appAgent)),
              filesURL: [],
              myAuxId: activeMyaux ? activeMyaux.id : "",
              // Vide oooooo
              author:
                user && JSON.parse(user)
                  ? JSON.parse(user)[0].f_Name + " " + JSON.parse(user)[0].l_Name
                  : "",
            })
          );
          firstCompletion = false;
          setIsStartCompletion(firstCompletion);
          setIsNewConversationAliasSet(true);
          break;
          return;
        }
        // info: L'activeAgentCompletion est met lent √† se mettre √† jour,
        // donc on va tracker la creation de la completion et le mise √† jour de la completion
        // par des variables locales

        const chunk = decoder.decode(value, { stream: true });

        completion += chunk;

        if (firstCompletion === false) {
          firstCompletion = true;
          dispatch(
            createStreamAction({
              conversationId: conversationId,
              agent: appAgent,
              content: completion,
            })
          );
        } else {
          dispatch(
            updateStreamContentAction({
              conversationId: conversationId,
              agent: appAgent,
              content: completion,
            })
          );
        }
      }

```

---

c'est pour cela qu'on a cette genre de code pour la fa√ßon dont on fait **l'affichage de le completion sur le page web** dans `ChatMessage.tsx`

### Affichage de la completion sur le page web

```tsx
...
  return (
      <div className="m-chat-scroller scroll-chat">
        {isLoading ? (
          <ChatSkeleton />
        ) : (
          <>
            {messageItems.map((m, index) => {
              switch (m.type) {
                case "human":
                  return <UserMessage key={index} content={m.content} files={m.filesURL} author={m.author} createdAt={m.createdAt}/>;
                case MessageType.Error:
                  return <ErrorMessage key={index} message={m} />;
                default:
                  return <AIMessage key={index} message={m} />;
              }
            })}

            {activeAgentCompletion &&
              (formatMessageAI(activeAgentCompletion.content)
                .query.replace(/<ignore>/g, "")
                .trim() !== "" ? (
                <CompletionMessage
                  conversationId={conversationId}
                  completionAI={queryReverter(
                    urlCollectionTabs,
                    activeAgentCompletion.content
                  )}
                  isCompletion={isStartCompletion}
                  setIsBotLoading={setIsBotLoading}
                />
              ) : (
                <LoadingText text={getAgentName(appAgent) === "" ? myAuxName : getAgentName(appAgent)} />
              ))}
          </>
        )}
      </div>
  );
```

> Les messages d'abord, tout en bas des messages le completion temporaire d'une nouvelle r√©ponse.



De rien lesy üòä








