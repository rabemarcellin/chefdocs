import FolderTree from "../../ui/FolderTree"
import { completionConcerns, concernedFolderAndFiles, viewConcerns, promptConcerns } from "./data"
import UserPromptForm from "../path/UserPromptForm"
import MessageSlice from "../path/MessageSlice"

# Prompting

Le `Prompting` ici est tout ce qui concerne la configuration de notre prompt,

- de la formulation de notre r√©quete(question ou demande) dans le formulaire d'input
- de choisir quel agent utilis√©
- c'est nous qui decidons des sources auquel l'agent va se bas√© pour nous r√©pondre selon ce qu'on peut utiliser: `document`, `internet`, ou les deux en m√™me temps.
- Le choix de la conversation n'est plus √† dire, car il faut choisir en juste une.

---
### La formulation de la r√©quete
Principalement, on va faire tout cela dans le fichier `UserPromptForm.tsx` pour la formulation de la r√©quete et son envoi au backend.
<FolderTree
  data={UserPromptForm}
/>

Ce qu'on doit faire en gros, c'est de envoyer notre prompt au serveur, juste cela. Avec certaine param√®tre certes, 
comme la discussion qu'on a s√©l√©ctionn√©, l'agent qu'on a s√©l√©ctionn√© pour r√©pondre, utiliser les `documents`ou non. 

Mais dans la forme la plus basique on fait juste une appel api au serveur, et on leur passe en param√®tres notre prompt. Haha

Rien de plus normale qu'un envoi de question au serveur via un appel api.

Et de r√©cevoir la r√©ponse de celle-ci en response.

--- 

<div className="tip">
Mais il faut qu'on s'assure qu'on a une discussion d'abord, car les questions et les r√©ponses sont cens√©s √™tre stock√©s dans une discussion.
**C'est pour cela qu'au premier lettre √©crit dans la formulaire input, on cr√©er tout de suite une discussion une discussion pour stocker tout ce qui va se passer en suite.**
</div>

### C√¥t√© code 

Les discussions(conversations) sont stock√©s dans le state redux ```state.conversation.items```et la conversation active dans ```state.conversation.active```
que l'on r√©cupere par les selectors ```selectConversationItems``` et ```selectConversationActive```

```tsx
// path: src/store/features/conversationSlice/selector.ts

const selectConversationItems = (state: RootState) => state.conversation.items;
const selectConversationActive = (state: RootState) => state.conversation.active;
```

Donc on v√©rifie dans la collection ou le projet si ce collection ou ce projet a au moins une discussion et que s'il n'en a pas, alors que 
l'utilisateur est entrain d'√©crire alors il faut vite lui en cr√©er une automatiquement.

Une fois l'utilisateur arrive √† formuler ce qu'il/elle veut demander.

- On enregistre son message dans la pile de message(dans le state)
- On envoie son prompt au serveur

--- 

### Le state des messages

Le state qui g√®re les messages le `messageSlice`

<FolderTree
  data={MessageSlice}
/>

Ce state a une action `addMessageAction` qui permet d'ajouter un message dans la pile de message(dans le state)
que ce soit le message de l'utilisateur ou bien la r√©ponse de l'agent, ou bien m√™me le message d'erreur.
C'est le seule action qu'on utilise. Les messages sont ensuite stock√©s dans `state.message.items` r√©cuperable via
le selector `conversationMessageSelector` pour les messages d'une conversation sp√©cifique.

```tsx

// R√©cuperation des messages d'une discussion sp√©cifique
const conversationId = "id de la discussion";
const conversationMessages = useAppSelector(conversationMessageSelector(conversationId));


// Ajout d'un message dans le state
const dispatch = useAppDispatch();

// Exemple de state d'un message d'un utilisateur
const message = {
    content: "Le texte √©crit dans l'input",
    type: "prompt de l'utilisateur ou r√©ponse de l'IA",
    name: getAgentName(agent) === "" ? myAuxName : getAgentName(agent),
    id: "...",
    createdAt: "...",
    conversationId: "id de la discussion",
    agentChanged: false,
    filesURL: "l'url d'un image si on veut envoyer une image",
    myAuxId: "l'id de myAux", // √† remplir si l'agent est un myAux
    author: "Le nom de la personne qui a √©crit le message"
}

dispatch(addMessageAction(message));

```

On en passe beaucoup de chose mais l'essentiel c'est qu'on enregistre:
- la question de telle utilisateur de telle nom
- dans telle discussion
- une question qu'il/elle a pos√© √† telle agent
- avec telle image
- √† telle moment


Ou bien
- une r√©ponse de telle agent
- dans telle discussion

---

Apr√®s avoir enregistrer la question/ ou la demande de l'utilisateur dans le state. On envoie maintenant le prompt dans 
le serveur et le tour est jou√©. Haha 

Comme on a dit, c'est juste un appel api. Donc la fonction se trouve dans le dossier service `src/services/api`
Tu trouveras une fichier `chat.ts` dans ce dossier o√π j'ai cr√©er la fonction `askAgentService`qui fait le tout.

```tsx
// path: src/services/api/chat.ts

export const askAgentService = async (
  agent: AgentType,
  body: FormData
): Promise<StreamResponse> => {
  const token = Cookies.get("user");
  const uri = getAgentUrl(agent);
  const secureHeaders = {
    ...(token && { Authorization: `Bearer ${token}` }),
  };
  const response = await fetch(`${API_BASE_URL}/chat${uri}`, {
    method: "POST",
    headers: {
      ...secureHeaders,
    },
    body: body,
  });
  if (!response.ok) {
    return {
      status: "error",
      data: await response.json(),
    };
  }

  const reader = response.body?.getReader();

  if (!reader) {
    throw new Error("No reader found");
  }

  return {
    status: "success",
    data: reader,
  };
};
```

Le chose important √† tenir ici c'est qu'on envoie pas une requ√™te api de type POST r√©gulier, on l'envoie en type `octect/stream`.
En fait le truc, c'est de dire au serveur de pouvoir r√©cup√©rer la r√©ponse de ma question petit √† petit.
Pour cela il faut envoyer la requ√™te en type `octect/stream`. 
c'est comme envoyer une requ√™te en `mulitpart/form-data` mais ici c'est en `octect/stream`.

<div className="tip">
  `multipart/form-data` c'est pour l'envoie de fichier.

  `octect/stream` c'est pour r√©cuperation de la r√©ponse en streaming(petit √† petit), comme la progression des films sur les sites de streaming en fait.
  c'est pas r√©cuperer en une seule fois mais bout √† bout.
</div>

---

Une fois que c'est fait, on attend juste la r√©ponse en fait üëâ‚Äãüëà‚Äã

<div class="note">
N.B: Le format de gestion des r√©quetes des octect/stream est d√©j√† comme je l'ai √©crit en haut lesy. Tu peux en faire des recherches sur cela car √ßa va pas du tout changer
en quoi que ce soit dans les tuto üòÖ Mais peut-√™tre que eux pourront bien expliquer mieux que moi.
</div>








